Service:
  RegionId: cn-hangzhou
  DeployType: ros
  OperationMetadata:
    StatusOperationConfigs:
    - TemplateName: ECS单机版
      SupportOperations:
      - Start
      - Stop
      - Restart
    SupportBackup: true
    ModifyParametersConfig:
    - TemplateName: ECS单机版
      Operation:
      - Name: 变更ECS实例规格
        Description: 变更ECS实例规格
        Type: Custom
        Parameters:
        - EcsInstanceType
      - Name: 变更ECS实例密码
        Description: 变更ECS实例密码
        Type: Custom
        Parameters:
        - InstancePassword
    ParameterConfigs:
    - TemplateName: 'ECS单机版'
      Parameters:
        CODE_SERVER_PASSWORD:
          Type: String
          Label: CodeServer服务登录密码
          Default: ''
          Required: true
      Metadata:
        ParameterGroups:
        - Parameters:
          - CODE_SERVER_PASSWORD
          DefaultEnvFilePath: ../.env
          Formatter: env
          Name: Default
  UpgradeMetadata:
    Description: 升级
    SupportUpgradeFromVersions: []
    SupportRollback: true
    UpgradeComponents:
    - Configuration
    - Resource
  DeployMetadata:
    SupplierDeployMetadata:
      SupplierTemplateConfigs:
      - Name: ECS单机版
        Url: 'ros_templates/template.yaml'
        ArchitectureDiagramUrl: 'resources/architecture/architecture.jpg'
        AllowedRegions:
        - ap-southeast-1
      ArtifactRelation:
        ecs_image_quickstart-code-server:
          ArtifactId: ${Artifact.EcsImage.ArtifactId}
          ArtifactVersion: draft
    TemplateConfigs:
    - Name: ECS单机版
      Url: 'ros_templates/template.yaml'
      ArchitectureDiagramUrl: 'resources/architecture/architecture.jpg'
      AllowedRegions:
      - ap-southeast-1
  ServiceType: private
  ServiceInfo:
    # 英文版可以再配置Locale为en-US的服务信息
  - Locale: zh-CN
    Name: CedeServer社区版
    ShortDescription: Code Server 是一个开源项目，它允许你在远程服务器或云环境中运行 Visual Studio Code（VS
      Code），并通过浏览器访问和使用它。简单来说，Code Server 就是 VS Code 的“网页版”，让你可以在任何设备、任何地方通过浏览器编写代码，而无需在本地安装完整的开发环境。
    Image: 
      https://service-info-public.oss-cn-hangzhou.aliyuncs.com/1853370294850618/service-image/5ace9c74-8969-4755-8de4-f0982b46f5e1.jpg
    Softwares: []
Artifact:
  EcsImage:
    ArtifactType: EcsImage
    ArtifactName: ecs_image_quickstart-code-server
    Description: quickstart-code-server EcsImage
    SupportRegionIds:
    - ap-southeast-1
    ArtifactBuildProperty:
      CodeRepo:
        Platform: github
        Owner: Alicloud-ComputeNest
        RepoName: aliyun-computenest/quickstart-code-server
        Branch: main
      RegionId: ap-southeast-1
      CommandType: RunShellScript
      SystemDiskSize: 40
      CommandContent: |-
        #!/bin/bash
        mkdir -p /root/application
        if [ -e "/root/code/config" ]; then cp -r "/root/code/config" "/root/application/"; fi
        if [ -e "/root/code/project" ]; then cp -r "/root/code/project" "/root/application/"; fi
        if [ -e "/root/code/docker-compose.yaml" ]; then cp -r "/root/code/docker-compose.yaml" "/root/application/"; fi
        if [ -e "/root/code/.env" ]; then cp -r "/root/code/.env" "/root/application/"; fi
        cd /root/application
        sed -i 's/pull_policy: always/pull_policy: if_not_present/g' docker-compose.yaml
        docker compose -f docker-compose.yaml build 
        docker compose -f docker-compose.yaml pull 2>&1 | stdbuf -oL grep -viE 'Downloading|sha256|extracting|KiB|Downloaded' || true;

        # 卸载ssh-guard相关组件
        if command -v yum &> /dev/null; then
            yum remove -y t-aliyun-security-sshguard t-aliyun-security-daemon t-aliyun-security-logtailer
        elif command -v apt-get &> /dev/null; then
            apt-get remove -y t-aliyun-security-sshguard t-aliyun-security-daemon t-aliyun-security-logtailer
            apt-get autoremove -y
        else
            echo "未找到支持的包管理器"
            exit 1
        fi

        rm -rf /opt/aliyun-security /usr/local/bin/sshguardctl /usr/local/bin/cloud-scra /run/aliyun-security--da

        sed -i '\#/usr/local/bin/sshguardctl#d' /etc/pam.d/sshd /etc/pam.d/common-auth

        # 清理账号密码
        # 1.清空root、admin账号密码：
        echo '1.开始清理root和admin账号密码...'
        sed -i 's/\(^root:\)[^:]*/\1!!/' /etc/shadow
        sed -i 's/\(^admin:\)[^:]*/\1!!/' /etc/shadow
        echo '1.root和admin账号密码清理完毕！'


        echo '2.开始清理其他账号(排除root和admin)...'
        # 定义排除的用户名列表
        exclude_users=("root" "admin")

        while IFS=: read -r username _ _ _ _ homedir user_shell; do
          # 检查 shell 类型是否符合给定的列表
          case $user_shell in
            '/bin/bash'|'/bin/sh'|'/bin/zsh'\
            |'/usr/bin/bash'|'/usr/bin/sh'|'/usr/bin/zsh'\
            |'/usr/local/bin/bash'|'/usr/local/bin/sh'|'/usr/local/bin/zsh')

              # 检查用户名是否在排除列表中
              if [[ ! " ${exclude_users[@]} " =~ " $username " ]]; then

                # 读取用户对应的密码信息
                pass=$(grep "^$username:" /etc/shadow | cut -d: -f2)

                # 进行密码状态的检查
                if [[ "$pass" == "!" || "$pass" == "!!" || "$pass" == *\!* || "$pass" == "*" ]]; then
                  echo "账号 $username 的密码被锁定或禁用，将不进行删除操作。"
                  continue
                fi

                # 符合条件的账号，进行清理操作
                echo '开始清理账号:' $username
                userdel -r "$username" 2>/dev/null
                if [[ -d "$homedir" ]]; then
                  rm -rf "$homedir" 2>/dev/null
                fi
              fi
              ;;

            # 如果 user_shell 不符合列表中的任何一个，此用户将被忽略
            *)
              continue
              ;;
          esac
        done < /etc/passwd
        echo '2.其他账号(排除root和admin)清理完毕！'

        echo '3.开始清理home目录下以.DEL结尾的目录...'
        # 从 /etc/passwd 读取并过滤出使用指定列表中的shell的用户数据
        while IFS=: read -r username _ _ _ _ homedir user_shell; do
          case $user_shell in
            '/bin/bash'|'/bin/sh'|'/bin/zsh'\
            |'/usr/bin/bash'|'/usr/bin/sh'|'/usr/bin/zsh'\
            |'/usr/local/bin/bash'|'/usr/local/bin/sh'|'/usr/local/bin/zsh')
              # 若home目录存在，则查找以 .DEL 结尾的目录并删除它们
              if [[ -d "$homedir" ]]; then
                find "$homedir" -maxdepth 1 -type d -name '*.DEL' -exec rm -rf {} \;
              fi
              ;;
          esac
        done < /etc/passwd
        echo '3.清理home目录下以.DEL结尾的目录完毕！'

        # 验证步骤
        echo '4.开始验证清理操作是否生效...'

        # 验证root和admin密码是否被清空
        root_pass=$(grep "^root:" /etc/shadow | cut -d: -f2)
        admin_pass=$(grep "^admin:" /etc/shadow | cut -d: -f2)
        if [[ "$root_pass" == "!!" || -z "$admin_pass" ]]; then
          echo '验证：root账号密码清理生效。'
        else
          echo '验证：root账号密码清理失败。'
        fi
        if [[ "$admin_pass" == "!!" || -z "$admin_pass" ]]; then
          echo '验证：admin账号密码清理生效。'
        else
          echo '验证：admin账号密码清理失败。'
        fi

        # 验证其他账号是否被清理
        user_exists=0
        while IFS=: read -r username _ _ _ _ homedir user_shell; do
          # 检查 shell 类型是否符合给定的列表
          case $user_shell in
            '/bin/bash'|'/bin/sh'|'/bin/zsh'\
            |'/usr/bin/bash'|'/usr/bin/sh'|'/usr/bin/zsh'\
            |'/usr/local/bin/bash'|'/usr/local/bin/sh'|'/usr/local/bin/zsh')

              if [[ ! " ${exclude_users[@]} " =~ " $username " ]]; then
                echo "验证失败：用户 $username 仍然存在。"
                user_exists=1
              fi
              ;;
          esac
        done < /etc/passwd

        if [[ $user_exists -eq 0 ]]; then
          echo '验证：其他账号清理生效。'
        fi

        # 检查home目录中是否存在以.DEL结尾的目录
        del_dir_exists=0
        while IFS=: read -r username _ _ _ _ homedir user_shell; do
          if [[ -d "$homedir" && -n $(find "$homedir" -maxdepth 1 -type d -name '*.DEL') ]]; then
            echo "验证失败：目录 $homedir 下仍然存在.DEL结尾的目录。"
            del_dir_exists=1
          fi
        done < /etc/passwd

        if [[ $del_dir_exists -eq 0 ]]; then
          echo '验证：home目录下以.DEL结尾的目录清理生效。'
        fi

        echo '验证步骤完成！'
